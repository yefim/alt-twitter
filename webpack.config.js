const path = require("path");
const webpack = require("webpack");
const packageJson = require("./package.json");
const { CleanWebpackPlugin } = require("clean-webpack-plugin");
const CopyWebpackPlugin = require("copy-webpack-plugin");
const ZipPlugin = require("zip-webpack-plugin");

module.exports = (env, argv) => {
  const isDev = argv.mode === "development";
  return {
    entry: {
      example: "./src/contentScripts/example.ts",
    },

    // Use built-in optimizations based on mode
    // https://webpack.js.org/configuration/mode/
    mode: "development",

    // Source maps must be inline to work with TypeScript
    devtool: "cheap-module-inline-source-map",

    module: {
      rules: [
        // JS
        {
          test: /\.js(x?)$/,
          exclude: /node_modules/,
          use: ["babel-loader", "eslint-loader"],
        },

        // Typescript
        {
          test: /\.ts(x?)$/,
          exclude: /node_modules/,
          use: [
            { loader: "babel-loader" },
            {
              // ts-loader is used for transpiling to generate source maps
              loader: "ts-loader",
              options: {
                // Skip type checking while developing but enforce for production
                transpileOnly: isDev,
              },
            },
            { loader: "eslint-loader" },
          ],
        },
      ],
    },

    resolve: {
      // Allow leaving off extensions when importing
      extensions: [".js", ".jsx", ".ts", ".tsx"],
      // Allow importing directly from these directories
      modules: [path.resolve(__dirname, "src"), "node_modules"],
    },

    output: {
      path: path.resolve(__dirname, isDev ? "dist-dev" : "dist-prod"),
      filename: "[name].bundle.js",
    },

    devServer: {
      contentBase: path.join(__dirname, "dist-dev"),
      port: 3000,
      hot: true,
      // Display all files when navigating to /
      writeToDisk: true,
      // Allow live reloading / HMR when extension is loaded in Chrome
      disableHostCheck: true,
    },

    plugins: [
      new webpack.DefinePlugin({
        PLATFORM:
          env && env.platform === "firefox"
            ? JSON.stringify("firefox")
            : JSON.stringify("chrome"),
      }),

      // Clean build folder
      new CleanWebpackPlugin({
        // Prevent cleaning copied files since copy-webpack-plugin does not regenerate unchanged files
        cleanStaleWebpackAssets: false,
      }),

      // Copy manifest.json to build folder
      new CopyWebpackPlugin({
        patterns: [
          {
            from: "src/manifest.json",
            transform: (content) => {
              const manifest = JSON.parse(content.toString());
              // Use fields from package.json for manifest
              const manifestFields = {
                description: packageJson.description,
                version: packageJson.version,
              };
              // Use 'unsafe-eval' to allow eval() generated by webpack in development mode
              manifestFields["content_security_policy"] = `script-src 'self' ${
                isDev ? "'unsafe-eval'" : ""
              }; object-src 'self'`;
              if (env && env.platform === "firefox") {
                // Incognito 'split' mode is not supported on Firefox
                if (manifest.incognito === "split") {
                  delete manifest.incognito;
                }
                // Assign an add-on ID to use storage.sync
                // https://extensionworkshop.com/documentation/develop/testing-persistent-and-restart-features/
                if (isDev) {
                  manifestFields.applications = {
                    gecko: {
                      id: "name@domain.com",
                    },
                  };
                }
              }
              // Add fields to the manifest file using package.json
              return Buffer.from(
                JSON.stringify({
                  ...manifestFields,
                  ...manifest,
                })
              );
            },
          },
        ],
      }),

      !isDev &&
        new ZipPlugin({
          filename: `${packageJson.name}-v${packageJson.version}.zip`,
        }),
    ].filter((plugin) => !!plugin),
  };
};
